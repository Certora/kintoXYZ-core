// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.18;

import "forge-std/Test.sol";
import "forge-std/console.sol";

import "@aa/interfaces/IEntryPoint.sol";
import "@aa/core/EntryPoint.sol";

import "../src/wallet/KintoWallet.sol";
import "../src/wallet/KintoWalletFactory.sol";
import "../src/paymasters/SponsorPaymaster.sol";
import "../src/KintoID.sol";
import "../src/sample/Counter.sol";

import "./helpers/UserOp.sol";
import "./helpers/KYCSignature.sol";
import {AATestScaffolding} from "./helpers/AATestScaffolding.sol";

contract MyOpCreator is UserOp, KYCSignature {
    function _createOp(
        uint256 _chainID,
        address _account,
        uint256 nonce,
        uint256[] calldata _privateKeyOwners,
        address _target,
        uint256 value,
        bytes calldata _bytesOp,
        address _paymaster
    ) public view returns (UserOperation memory op) {
        op = UserOperation({
            sender: _account,
            nonce: nonce,
            initCode: bytes(""),
            callData: abi.encodeCall(KintoWallet.execute, (_target, value, _bytesOp)),
            callGasLimit: 40000, // generate from call simulation
            verificationGasLimit: 150000, // verification gas. will add create2 cost (3200+200*length) if initCode exists
            preVerificationGas: 99e18, // should also cover calldata cost.
            maxFeePerGas: 1, // grab from current gas
            maxPriorityFeePerGas: 1e9, // grab from current gas
            paymasterAndData: abi.encodePacked(_paymaster),
            signature: bytes("")
        });
        op.signature = _signUserOp(op, KintoWallet(payable(_account)).entryPoint(), _chainID, _privateKeyOwners);
        return op;
    }
}

contract SponsorPaymasterExploitTest is MyOpCreator, AATestScaffolding {
    using ECDSAUpgradeable for bytes32;
    using SignatureChecker for address;

    uint256 _chainID = 1;

    function setUp() public {
        vm.chainId(_chainID);
        vm.startPrank(address(1));
        _owner.transfer(1e18);
        vm.stopPrank();
        deployAAScaffolding(_owner, 1, _kycProvider, _recoverer);
        fundSponsorForApp(address(_engenCredits));
        fundSponsorForApp(address(_kintoWallet));
    }

    function testExploit() public {
        vm.startPrank(_owner);
        // Let's deploy the counter contract
        Counter counter = new Counter();
        assertEq(counter.count(), 0);
        vm.stopPrank();
        fundSponsorForApp(address(counter));
        vm.startPrank(_owner);
        // Let's send a transaction to the counter contract through our wallet
        uint256 nonce = _kintoWallet.getNonce();
        uint256[] memory privateKeys = new uint256[](1);
        privateKeys[0] = 1;

        UserOperation memory userOp = this._createOp(
            _chainID,
            address(_kintoWallet),
            nonce,
            privateKeys,
            address(counter),
            0,
            abi.encodeWithSignature("increment()"),
            address(_paymaster)
        );
        UserOperation[] memory userOps = new UserOperation[](1);
        userOps[0] = userOp;
        uint256 balanceBefore = _owner.balance;
        console.log("HACKER BALANCE BEFORE", balanceBefore);
        vm.expectRevert();
        _entryPoint.handleOps(userOps, payable(_owner));
        uint256 balanceAfter = _owner.balance;
        uint256 dust = 100_000;
        assertGt(balanceBefore, balanceAfter - dust, "Hacker's profit is too HIGH");

        vm.stopPrank();
    }
}
