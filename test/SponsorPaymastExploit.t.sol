// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "../src/wallet/KintoWallet.sol";
import "../src/wallet/KintoWalletFactory.sol";
import "../src/paymasters/SponsorPaymaster.sol";
import "../src/KintoID.sol";
import {UserOp} from "./helpers/UserOp.sol";
import {UUPSProxy} from "./helpers/UUPSProxy.sol";
import {KYCSignature} from "./helpers/KYCSignature.sol";

import "@aa/interfaces/IAccount.sol";
import "@aa/interfaces/INonceManager.sol";
import "@aa/interfaces/IEntryPoint.sol";
import "@aa/core/EntryPoint.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol";
import {UpgradeableBeacon} from "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol";
import {SignatureChecker} from "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract MyOpCreator is UserOp, KYCSignature {
    function _createOp(
        uint256 _chainID,
        address _account,
        uint256 nonce,
        uint256[] calldata _privateKeyOwners,
        address _targetContract,
        uint256 value,
        bytes calldata _bytesOp,
        address _paymaster
    ) public returns (UserOperation memory op) {
        op = UserOperation({
            sender: _account,
            nonce: nonce,
            initCode: bytes(""),
            callData: abi.encodeCall(KintoWallet.execute, (_targetContract, value, _bytesOp)),
            callGasLimit: 40000, // generate from call simulation
            verificationGasLimit: 150000, // verification gas. will add create2 cost (3200+200*length) if initCode exists
            preVerificationGas: 99e18, // should also cover calldata cost.
            maxFeePerGas: 1, // grab from current gas
            maxPriorityFeePerGas: 1e9, // grab from current gas
            paymasterAndData: abi.encodePacked(_paymaster),
            signature: bytes("")
        });
        op.signature = _signUserOp(op, KintoWallet(payable(_account)).entryPoint(), _chainID, _privateKeyOwners);
        return op;
    }
}

contract Counter {
    uint256 public count;

    constructor() {
        count = 0;
    }

    function increment() public {
        count += 1;
    }
}

contract SponsorPaymasterExploitTest is MyOpCreator {
    using ECDSAUpgradeable for bytes32;
    using SignatureChecker for address;

    EntryPoint _entryPoint;
    KintoWalletFactory _walletFactoryI;
    KintoWalletFactory _walletFactory;
    KintoID _implementation;
    KintoID _kintoIDv1;
    SponsorPaymaster _paymaster;

    KintoWallet _kintoWalletImpl;
    IKintoWallet _kintoWalletv1;
    UUPSProxy _proxy;
    UUPSProxy _proxyf;
    UUPSProxy _proxys;
    UpgradeableBeacon _beacon;

    uint256 _chainID = 1;

    function setUp() public {
        vm.chainId(_chainID);
        vm.startPrank(address(1));
        _owner.transfer(1e18);
        vm.stopPrank();
        vm.startPrank(_owner);
        // Deploy Kinto ID
        _implementation = new KintoID();
        // deploy _proxy contract and point it to _implementation
        _proxy = new UUPSProxy{salt: 0}(address(_implementation), "");
        // wrap in ABI to support easier calls
        _kintoIDv1 = KintoID(address(_proxy));
        // Initialize _proxy
        _kintoIDv1.initialize();
        _kintoIDv1.grantRole(_kintoIDv1.KYC_PROVIDER_ROLE(), _kycProvider);
        _entryPoint = new EntryPoint{salt: 0}();
        // Deploy wallet implementation
        _kintoWalletImpl = new KintoWallet{salt: 0}(_entryPoint, _kintoIDv1);
        //Deploy wallet factory implementation
        _walletFactoryI = new KintoWalletFactory{salt: 0}(_kintoWalletImpl);
        _proxyf = new UUPSProxy{salt: 0}(address(_walletFactoryI), "");
        _walletFactory = KintoWalletFactory(address(_proxyf));
        // Initialize wallet factory
        _walletFactory.initialize(_kintoIDv1);
        // Set the wallet factory in the entry point
        _entryPoint.setWalletFactory(address(_walletFactory));
        // Mint an nft to the owner
        IKintoID.SignatureData memory sigdata =
            _auxCreateSignature(_kintoIDv1, _owner, _owner, 1, block.timestamp + 1000);
        uint8[] memory traits = new uint8[](0);
        vm.startPrank(_kycProvider);
        _kintoIDv1.mintIndividualKyc(sigdata, traits);
        vm.stopPrank();
        vm.startPrank(_owner);
        // deploy walletv1 through wallet factory and initializes it
        _kintoWalletv1 = _walletFactory.createAccount(_owner, _recoverer, 0);
        console.log("wallet address ", address(_kintoWalletv1));
        // deploy the paymaster
        _paymaster = new SponsorPaymaster{salt: 0}(_entryPoint);
        // deploy _proxy contract and point it to _implementation
        _proxys = new UUPSProxy(address(_paymaster), "");
        // wrap in ABI to support easier calls
        _paymaster = SponsorPaymaster(address(_proxys));
        // Initialize proxy
        _paymaster.initialize(_owner);
        vm.stopPrank();
    }

    function testExploit() public {
        vm.startPrank(_owner);
        // Let's deploy the counter contract
        Counter counter = new Counter();
        assertEq(counter.count(), 0);
        vm.stopPrank();
        _fundPaymasterForContract(address(counter));
        vm.startPrank(_owner);
        // Let's send a transaction to the counter contract through our wallet
        uint256 startingNonce = _kintoWalletv1.getNonce();
        uint256[] memory privateKeys = new uint256[](1);
        privateKeys[0] = 1;

        UserOperation memory userOp = this._createOp(
            _chainID,
            address(_kintoWalletv1),
            startingNonce,
            privateKeys,
            address(counter),
            0,
            abi.encodeWithSignature("increment()"),
            address(_paymaster)
        );
        UserOperation[] memory userOps = new UserOperation[](1);
        userOps[0] = userOp;
        // Execute the transaction via the entry point
        uint256 balanceBefore = _owner.balance;
        console.log("HACKER BALANCE BEFORE", balanceBefore);
        vm.expectRevert();
        _entryPoint.handleOps(userOps, payable(_owner));
        uint256 balanceAfter = _owner.balance;
        uint256 dust = 100_000;
        assertGt(balanceBefore, balanceAfter - dust, "Hacker's profit is too HIGH");

        vm.stopPrank();
    }

    // funds contract so paymaster can use to pay for gas
    function _fundPaymasterForContract(address _contract) private {
        vm.startPrank(_owner);
        vm.deal(_owner, 1000e18);
        // We add the deposit to the counter contract in the paymaster
        _paymaster.addDepositFor{value: 100e18}(address(_contract));
        vm.stopPrank();
    }
}
